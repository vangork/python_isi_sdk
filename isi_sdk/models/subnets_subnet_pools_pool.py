# coding: utf-8

"""
    Isilon SDK

    Isilon SDK - Language bindings for the OneFS API  # noqa: E501

    OpenAPI spec version: 22
    Contact: sdk@isilon.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from isi_sdk.configuration import Configuration


class SubnetsSubnetPoolsPool(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'access_zone': 'str',
        'addr_family': 'str',
        'aggregation_mode': 'str',
        'alloc_method': 'str',
        'description': 'str',
        'external_manager': 'str',
        'firewall_policy': 'str',
        'groupnet': 'str',
        'id': 'str',
        'ifaces': 'list[SubnetsSubnetPoolIface]',
        'ipv6_perform_dad': 'bool',
        'linklayer': 'str',
        'name': 'str',
        'nfs_rroce_only': 'bool',
        'ranges': 'list[SubnetsSubnetPoolRange]',
        'rebalance_policy': 'str',
        'rules': 'list[str]',
        'sc_connect_policy': 'str',
        'sc_dns_zone': 'str',
        'sc_dns_zone_aliases': 'list[str]',
        'sc_failover_policy': 'str',
        'sc_subnet': 'str',
        'sc_suspended_nodes': 'list[int]',
        'sc_ttl': 'int',
        'static_routes': 'list[SubnetsSubnetPoolStaticRoute]',
        'subnet': 'str'
    }

    attribute_map = {
        'access_zone': 'access_zone',
        'addr_family': 'addr_family',
        'aggregation_mode': 'aggregation_mode',
        'alloc_method': 'alloc_method',
        'description': 'description',
        'external_manager': 'external_manager',
        'firewall_policy': 'firewall_policy',
        'groupnet': 'groupnet',
        'id': 'id',
        'ifaces': 'ifaces',
        'ipv6_perform_dad': 'ipv6_perform_dad',
        'linklayer': 'linklayer',
        'name': 'name',
        'nfs_rroce_only': 'nfs_rroce_only',
        'ranges': 'ranges',
        'rebalance_policy': 'rebalance_policy',
        'rules': 'rules',
        'sc_connect_policy': 'sc_connect_policy',
        'sc_dns_zone': 'sc_dns_zone',
        'sc_dns_zone_aliases': 'sc_dns_zone_aliases',
        'sc_failover_policy': 'sc_failover_policy',
        'sc_subnet': 'sc_subnet',
        'sc_suspended_nodes': 'sc_suspended_nodes',
        'sc_ttl': 'sc_ttl',
        'static_routes': 'static_routes',
        'subnet': 'subnet'
    }

    def __init__(self, access_zone=None, addr_family=None, aggregation_mode=None, alloc_method=None, description=None, external_manager=None, firewall_policy=None, groupnet=None, id=None, ifaces=None, ipv6_perform_dad=None, linklayer=None, name=None, nfs_rroce_only=None, ranges=None, rebalance_policy=None, rules=None, sc_connect_policy=None, sc_dns_zone=None, sc_dns_zone_aliases=None, sc_failover_policy=None, sc_subnet=None, sc_suspended_nodes=None, sc_ttl=None, static_routes=None, subnet=None, _configuration=None):  # noqa: E501
        """SubnetsSubnetPoolsPool - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._access_zone = None
        self._addr_family = None
        self._aggregation_mode = None
        self._alloc_method = None
        self._description = None
        self._external_manager = None
        self._firewall_policy = None
        self._groupnet = None
        self._id = None
        self._ifaces = None
        self._ipv6_perform_dad = None
        self._linklayer = None
        self._name = None
        self._nfs_rroce_only = None
        self._ranges = None
        self._rebalance_policy = None
        self._rules = None
        self._sc_connect_policy = None
        self._sc_dns_zone = None
        self._sc_dns_zone_aliases = None
        self._sc_failover_policy = None
        self._sc_subnet = None
        self._sc_suspended_nodes = None
        self._sc_ttl = None
        self._static_routes = None
        self._subnet = None
        self.discriminator = None

        self.access_zone = access_zone
        self.addr_family = addr_family
        self.aggregation_mode = aggregation_mode
        self.alloc_method = alloc_method
        self.description = description
        if external_manager is not None:
            self.external_manager = external_manager
        self.firewall_policy = firewall_policy
        self.groupnet = groupnet
        self.id = id
        self.ifaces = ifaces
        self.ipv6_perform_dad = ipv6_perform_dad
        self.linklayer = linklayer
        self.name = name
        self.nfs_rroce_only = nfs_rroce_only
        self.ranges = ranges
        self.rebalance_policy = rebalance_policy
        self.rules = rules
        self.sc_connect_policy = sc_connect_policy
        self.sc_dns_zone = sc_dns_zone
        self.sc_dns_zone_aliases = sc_dns_zone_aliases
        self.sc_failover_policy = sc_failover_policy
        self.sc_subnet = sc_subnet
        self.sc_suspended_nodes = sc_suspended_nodes
        self.sc_ttl = sc_ttl
        self.static_routes = static_routes
        self.subnet = subnet

    @property
    def access_zone(self):
        """Gets the access_zone of this SubnetsSubnetPoolsPool.  # noqa: E501

        Name of a valid access zone to map IP address pool to the zone.  # noqa: E501

        :return: The access_zone of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._access_zone

    @access_zone.setter
    def access_zone(self, access_zone):
        """Sets the access_zone of this SubnetsSubnetPoolsPool.

        Name of a valid access zone to map IP address pool to the zone.  # noqa: E501

        :param access_zone: The access_zone of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and access_zone is None:
            raise ValueError("Invalid value for `access_zone`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                access_zone is not None and len(access_zone) > 255):
            raise ValueError("Invalid value for `access_zone`, length must be less than or equal to `255`")  # noqa: E501
        if (self._configuration.client_side_validation and
                access_zone is not None and len(access_zone) < 1):
            raise ValueError("Invalid value for `access_zone`, length must be greater than or equal to `1`")  # noqa: E501

        self._access_zone = access_zone

    @property
    def addr_family(self):
        """Gets the addr_family of this SubnetsSubnetPoolsPool.  # noqa: E501

        IP address format.  # noqa: E501

        :return: The addr_family of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._addr_family

    @addr_family.setter
    def addr_family(self, addr_family):
        """Sets the addr_family of this SubnetsSubnetPoolsPool.

        IP address format.  # noqa: E501

        :param addr_family: The addr_family of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and addr_family is None:
            raise ValueError("Invalid value for `addr_family`, must not be `None`")  # noqa: E501
        allowed_values = ["ipv4", "ipv6"]  # noqa: E501
        if (self._configuration.client_side_validation and
                addr_family not in allowed_values):
            raise ValueError(
                "Invalid value for `addr_family` ({0}), must be one of {1}"  # noqa: E501
                .format(addr_family, allowed_values)
            )

        self._addr_family = addr_family

    @property
    def aggregation_mode(self):
        """Gets the aggregation_mode of this SubnetsSubnetPoolsPool.  # noqa: E501

        OneFS supports the following NIC aggregation modes. 'fec' was renamed to 'loadbalance' in OneFS 9.7.  # noqa: E501

        :return: The aggregation_mode of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._aggregation_mode

    @aggregation_mode.setter
    def aggregation_mode(self, aggregation_mode):
        """Sets the aggregation_mode of this SubnetsSubnetPoolsPool.

        OneFS supports the following NIC aggregation modes. 'fec' was renamed to 'loadbalance' in OneFS 9.7.  # noqa: E501

        :param aggregation_mode: The aggregation_mode of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and aggregation_mode is None:
            raise ValueError("Invalid value for `aggregation_mode`, must not be `None`")  # noqa: E501
        allowed_values = ["roundrobin", "failover", "lacp", "loadbalance", "none"]  # noqa: E501
        if (self._configuration.client_side_validation and
                aggregation_mode not in allowed_values):
            raise ValueError(
                "Invalid value for `aggregation_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(aggregation_mode, allowed_values)
            )

        self._aggregation_mode = aggregation_mode

    @property
    def alloc_method(self):
        """Gets the alloc_method of this SubnetsSubnetPoolsPool.  # noqa: E501

        Specifies how IP address allocation is done among pool members.  # noqa: E501

        :return: The alloc_method of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._alloc_method

    @alloc_method.setter
    def alloc_method(self, alloc_method):
        """Sets the alloc_method of this SubnetsSubnetPoolsPool.

        Specifies how IP address allocation is done among pool members.  # noqa: E501

        :param alloc_method: The alloc_method of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and alloc_method is None:
            raise ValueError("Invalid value for `alloc_method`, must not be `None`")  # noqa: E501
        allowed_values = ["dynamic", "static", "externally_managed"]  # noqa: E501
        if (self._configuration.client_side_validation and
                alloc_method not in allowed_values):
            raise ValueError(
                "Invalid value for `alloc_method` ({0}), must be one of {1}"  # noqa: E501
                .format(alloc_method, allowed_values)
            )

        self._alloc_method = alloc_method

    @property
    def description(self):
        """Gets the description of this SubnetsSubnetPoolsPool.  # noqa: E501

        A description of the pool.  # noqa: E501

        :return: The description of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this SubnetsSubnetPoolsPool.

        A description of the pool.  # noqa: E501

        :param description: The description of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and description is None:
            raise ValueError("Invalid value for `description`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                description is not None and len(description) > 128):
            raise ValueError("Invalid value for `description`, length must be less than or equal to `128`")  # noqa: E501
        if (self._configuration.client_side_validation and
                description is not None and len(description) < 0):
            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501

        self._description = description

    @property
    def external_manager(self):
        """Gets the external_manager of this SubnetsSubnetPoolsPool.  # noqa: E501

        Name of the system allocating the IPs for this Network Pool.  # noqa: E501

        :return: The external_manager of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._external_manager

    @external_manager.setter
    def external_manager(self, external_manager):
        """Sets the external_manager of this SubnetsSubnetPoolsPool.

        Name of the system allocating the IPs for this Network Pool.  # noqa: E501

        :param external_manager: The external_manager of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                external_manager is not None and len(external_manager) > 128):
            raise ValueError("Invalid value for `external_manager`, length must be less than or equal to `128`")  # noqa: E501
        if (self._configuration.client_side_validation and
                external_manager is not None and len(external_manager) < 0):
            raise ValueError("Invalid value for `external_manager`, length must be greater than or equal to `0`")  # noqa: E501

        self._external_manager = external_manager

    @property
    def firewall_policy(self):
        """Gets the firewall_policy of this SubnetsSubnetPoolsPool.  # noqa: E501

        Name of the Firewall Policy associated with this Network Pool.  # noqa: E501

        :return: The firewall_policy of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._firewall_policy

    @firewall_policy.setter
    def firewall_policy(self, firewall_policy):
        """Sets the firewall_policy of this SubnetsSubnetPoolsPool.

        Name of the Firewall Policy associated with this Network Pool.  # noqa: E501

        :param firewall_policy: The firewall_policy of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and firewall_policy is None:
            raise ValueError("Invalid value for `firewall_policy`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                firewall_policy is not None and len(firewall_policy) > 32):
            raise ValueError("Invalid value for `firewall_policy`, length must be less than or equal to `32`")  # noqa: E501
        if (self._configuration.client_side_validation and
                firewall_policy is not None and len(firewall_policy) < 1):
            raise ValueError("Invalid value for `firewall_policy`, length must be greater than or equal to `1`")  # noqa: E501

        self._firewall_policy = firewall_policy

    @property
    def groupnet(self):
        """Gets the groupnet of this SubnetsSubnetPoolsPool.  # noqa: E501

        Name of the groupnet this pool belongs to.  # noqa: E501

        :return: The groupnet of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._groupnet

    @groupnet.setter
    def groupnet(self, groupnet):
        """Sets the groupnet of this SubnetsSubnetPoolsPool.

        Name of the groupnet this pool belongs to.  # noqa: E501

        :param groupnet: The groupnet of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and groupnet is None:
            raise ValueError("Invalid value for `groupnet`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                groupnet is not None and len(groupnet) > 32):
            raise ValueError("Invalid value for `groupnet`, length must be less than or equal to `32`")  # noqa: E501
        if (self._configuration.client_side_validation and
                groupnet is not None and len(groupnet) < 1):
            raise ValueError("Invalid value for `groupnet`, length must be greater than or equal to `1`")  # noqa: E501

        self._groupnet = groupnet

    @property
    def id(self):
        """Gets the id of this SubnetsSubnetPoolsPool.  # noqa: E501

        Unique Pool ID.  # noqa: E501

        :return: The id of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this SubnetsSubnetPoolsPool.

        Unique Pool ID.  # noqa: E501

        :param id: The id of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                id is not None and len(id) > 99):
            raise ValueError("Invalid value for `id`, length must be less than or equal to `99`")  # noqa: E501
        if (self._configuration.client_side_validation and
                id is not None and len(id) < 1):
            raise ValueError("Invalid value for `id`, length must be greater than or equal to `1`")  # noqa: E501

        self._id = id

    @property
    def ifaces(self):
        """Gets the ifaces of this SubnetsSubnetPoolsPool.  # noqa: E501

        List of interface members in this pool.  # noqa: E501

        :return: The ifaces of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: list[SubnetsSubnetPoolIface]
        """
        return self._ifaces

    @ifaces.setter
    def ifaces(self, ifaces):
        """Sets the ifaces of this SubnetsSubnetPoolsPool.

        List of interface members in this pool.  # noqa: E501

        :param ifaces: The ifaces of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: list[SubnetsSubnetPoolIface]
        """
        if self._configuration.client_side_validation and ifaces is None:
            raise ValueError("Invalid value for `ifaces`, must not be `None`")  # noqa: E501

        self._ifaces = ifaces

    @property
    def ipv6_perform_dad(self):
        """Gets the ipv6_perform_dad of this SubnetsSubnetPoolsPool.  # noqa: E501

        Indicates if the Network Pool should perform IPv6 Duplicate Address Detection when configuring the IPs. Only applies to IPv6 Network Pools.  # noqa: E501

        :return: The ipv6_perform_dad of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: bool
        """
        return self._ipv6_perform_dad

    @ipv6_perform_dad.setter
    def ipv6_perform_dad(self, ipv6_perform_dad):
        """Sets the ipv6_perform_dad of this SubnetsSubnetPoolsPool.

        Indicates if the Network Pool should perform IPv6 Duplicate Address Detection when configuring the IPs. Only applies to IPv6 Network Pools.  # noqa: E501

        :param ipv6_perform_dad: The ipv6_perform_dad of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and ipv6_perform_dad is None:
            raise ValueError("Invalid value for `ipv6_perform_dad`, must not be `None`")  # noqa: E501

        self._ipv6_perform_dad = ipv6_perform_dad

    @property
    def linklayer(self):
        """Gets the linklayer of this SubnetsSubnetPoolsPool.  # noqa: E501

        Specifies the type of network linklayer this Network Pool uses.  # noqa: E501

        :return: The linklayer of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._linklayer

    @linklayer.setter
    def linklayer(self, linklayer):
        """Sets the linklayer of this SubnetsSubnetPoolsPool.

        Specifies the type of network linklayer this Network Pool uses.  # noqa: E501

        :param linklayer: The linklayer of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and linklayer is None:
            raise ValueError("Invalid value for `linklayer`, must not be `None`")  # noqa: E501
        allowed_values = ["ethernet", "infiniband"]  # noqa: E501
        if (self._configuration.client_side_validation and
                linklayer not in allowed_values):
            raise ValueError(
                "Invalid value for `linklayer` ({0}), must be one of {1}"  # noqa: E501
                .format(linklayer, allowed_values)
            )

        self._linklayer = linklayer

    @property
    def name(self):
        """Gets the name of this SubnetsSubnetPoolsPool.  # noqa: E501

        The name of the pool. It must be unique throughout the given subnet.It's a required field with POST method.  # noqa: E501

        :return: The name of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this SubnetsSubnetPoolsPool.

        The name of the pool. It must be unique throughout the given subnet.It's a required field with POST method.  # noqa: E501

        :param name: The name of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                name is not None and len(name) > 32):
            raise ValueError("Invalid value for `name`, length must be less than or equal to `32`")  # noqa: E501
        if (self._configuration.client_side_validation and
                name is not None and len(name) < 1):
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501
        if (self._configuration.client_side_validation and
                name is not None and not re.search(r'^[0-9a-zA-Z_-]*$', name)):  # noqa: E501
            raise ValueError(r"Invalid value for `name`, must be a follow pattern or equal to `/^[0-9a-zA-Z_-]*$/`")  # noqa: E501

        self._name = name

    @property
    def nfs_rroce_only(self):
        """Gets the nfs_rroce_only of this SubnetsSubnetPoolsPool.  # noqa: E501

        Indicates that pool contains only RDMA RRoCE capable interfaces.  # noqa: E501

        :return: The nfs_rroce_only of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: bool
        """
        return self._nfs_rroce_only

    @nfs_rroce_only.setter
    def nfs_rroce_only(self, nfs_rroce_only):
        """Sets the nfs_rroce_only of this SubnetsSubnetPoolsPool.

        Indicates that pool contains only RDMA RRoCE capable interfaces.  # noqa: E501

        :param nfs_rroce_only: The nfs_rroce_only of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and nfs_rroce_only is None:
            raise ValueError("Invalid value for `nfs_rroce_only`, must not be `None`")  # noqa: E501

        self._nfs_rroce_only = nfs_rroce_only

    @property
    def ranges(self):
        """Gets the ranges of this SubnetsSubnetPoolsPool.  # noqa: E501

        List of IP address ranges in this pool.  # noqa: E501

        :return: The ranges of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: list[SubnetsSubnetPoolRange]
        """
        return self._ranges

    @ranges.setter
    def ranges(self, ranges):
        """Sets the ranges of this SubnetsSubnetPoolsPool.

        List of IP address ranges in this pool.  # noqa: E501

        :param ranges: The ranges of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: list[SubnetsSubnetPoolRange]
        """
        if self._configuration.client_side_validation and ranges is None:
            raise ValueError("Invalid value for `ranges`, must not be `None`")  # noqa: E501

        self._ranges = ranges

    @property
    def rebalance_policy(self):
        """Gets the rebalance_policy of this SubnetsSubnetPoolsPool.  # noqa: E501

        Rebalance policy.  # noqa: E501

        :return: The rebalance_policy of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._rebalance_policy

    @rebalance_policy.setter
    def rebalance_policy(self, rebalance_policy):
        """Sets the rebalance_policy of this SubnetsSubnetPoolsPool.

        Rebalance policy.  # noqa: E501

        :param rebalance_policy: The rebalance_policy of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and rebalance_policy is None:
            raise ValueError("Invalid value for `rebalance_policy`, must not be `None`")  # noqa: E501
        allowed_values = ["auto", "manual"]  # noqa: E501
        if (self._configuration.client_side_validation and
                rebalance_policy not in allowed_values):
            raise ValueError(
                "Invalid value for `rebalance_policy` ({0}), must be one of {1}"  # noqa: E501
                .format(rebalance_policy, allowed_values)
            )

        self._rebalance_policy = rebalance_policy

    @property
    def rules(self):
        """Gets the rules of this SubnetsSubnetPoolsPool.  # noqa: E501

        Names of the rules in this pool.  # noqa: E501

        :return: The rules of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: list[str]
        """
        return self._rules

    @rules.setter
    def rules(self, rules):
        """Sets the rules of this SubnetsSubnetPoolsPool.

        Names of the rules in this pool.  # noqa: E501

        :param rules: The rules of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: list[str]
        """
        if self._configuration.client_side_validation and rules is None:
            raise ValueError("Invalid value for `rules`, must not be `None`")  # noqa: E501

        self._rules = rules

    @property
    def sc_connect_policy(self):
        """Gets the sc_connect_policy of this SubnetsSubnetPoolsPool.  # noqa: E501

        SmartConnect client connection balancing policy.  # noqa: E501

        :return: The sc_connect_policy of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._sc_connect_policy

    @sc_connect_policy.setter
    def sc_connect_policy(self, sc_connect_policy):
        """Sets the sc_connect_policy of this SubnetsSubnetPoolsPool.

        SmartConnect client connection balancing policy.  # noqa: E501

        :param sc_connect_policy: The sc_connect_policy of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and sc_connect_policy is None:
            raise ValueError("Invalid value for `sc_connect_policy`, must not be `None`")  # noqa: E501
        allowed_values = ["round_robin", "conn_count", "throughput", "cpu_usage"]  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_connect_policy not in allowed_values):
            raise ValueError(
                "Invalid value for `sc_connect_policy` ({0}), must be one of {1}"  # noqa: E501
                .format(sc_connect_policy, allowed_values)
            )

        self._sc_connect_policy = sc_connect_policy

    @property
    def sc_dns_zone(self):
        """Gets the sc_dns_zone of this SubnetsSubnetPoolsPool.  # noqa: E501

        SmartConnect zone name for the pool.  # noqa: E501

        :return: The sc_dns_zone of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._sc_dns_zone

    @sc_dns_zone.setter
    def sc_dns_zone(self, sc_dns_zone):
        """Sets the sc_dns_zone of this SubnetsSubnetPoolsPool.

        SmartConnect zone name for the pool.  # noqa: E501

        :param sc_dns_zone: The sc_dns_zone of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and sc_dns_zone is None:
            raise ValueError("Invalid value for `sc_dns_zone`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_dns_zone is not None and len(sc_dns_zone) > 2048):
            raise ValueError("Invalid value for `sc_dns_zone`, length must be less than or equal to `2048`")  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_dns_zone is not None and len(sc_dns_zone) < 0):
            raise ValueError("Invalid value for `sc_dns_zone`, length must be greater than or equal to `0`")  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_dns_zone is not None and not re.search(r'^$|^[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]*)*$', sc_dns_zone)):  # noqa: E501
            raise ValueError(r"Invalid value for `sc_dns_zone`, must be a follow pattern or equal to `/^$|^[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]*)*$/`")  # noqa: E501

        self._sc_dns_zone = sc_dns_zone

    @property
    def sc_dns_zone_aliases(self):
        """Gets the sc_dns_zone_aliases of this SubnetsSubnetPoolsPool.  # noqa: E501

        List of SmartConnect zone aliases (DNS names) to the pool.  # noqa: E501

        :return: The sc_dns_zone_aliases of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: list[str]
        """
        return self._sc_dns_zone_aliases

    @sc_dns_zone_aliases.setter
    def sc_dns_zone_aliases(self, sc_dns_zone_aliases):
        """Sets the sc_dns_zone_aliases of this SubnetsSubnetPoolsPool.

        List of SmartConnect zone aliases (DNS names) to the pool.  # noqa: E501

        :param sc_dns_zone_aliases: The sc_dns_zone_aliases of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: list[str]
        """
        if self._configuration.client_side_validation and sc_dns_zone_aliases is None:
            raise ValueError("Invalid value for `sc_dns_zone_aliases`, must not be `None`")  # noqa: E501

        self._sc_dns_zone_aliases = sc_dns_zone_aliases

    @property
    def sc_failover_policy(self):
        """Gets the sc_failover_policy of this SubnetsSubnetPoolsPool.  # noqa: E501

        SmartConnect IP failover policy.  # noqa: E501

        :return: The sc_failover_policy of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._sc_failover_policy

    @sc_failover_policy.setter
    def sc_failover_policy(self, sc_failover_policy):
        """Sets the sc_failover_policy of this SubnetsSubnetPoolsPool.

        SmartConnect IP failover policy.  # noqa: E501

        :param sc_failover_policy: The sc_failover_policy of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and sc_failover_policy is None:
            raise ValueError("Invalid value for `sc_failover_policy`, must not be `None`")  # noqa: E501
        allowed_values = ["round_robin", "conn_count", "throughput", "cpu_usage"]  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_failover_policy not in allowed_values):
            raise ValueError(
                "Invalid value for `sc_failover_policy` ({0}), must be one of {1}"  # noqa: E501
                .format(sc_failover_policy, allowed_values)
            )

        self._sc_failover_policy = sc_failover_policy

    @property
    def sc_subnet(self):
        """Gets the sc_subnet of this SubnetsSubnetPoolsPool.  # noqa: E501

        Name of SmartConnect service subnet for this pool.  # noqa: E501

        :return: The sc_subnet of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._sc_subnet

    @sc_subnet.setter
    def sc_subnet(self, sc_subnet):
        """Sets the sc_subnet of this SubnetsSubnetPoolsPool.

        Name of SmartConnect service subnet for this pool.  # noqa: E501

        :param sc_subnet: The sc_subnet of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and sc_subnet is None:
            raise ValueError("Invalid value for `sc_subnet`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_subnet is not None and len(sc_subnet) > 32):
            raise ValueError("Invalid value for `sc_subnet`, length must be less than or equal to `32`")  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_subnet is not None and len(sc_subnet) < 0):
            raise ValueError("Invalid value for `sc_subnet`, length must be greater than or equal to `0`")  # noqa: E501

        self._sc_subnet = sc_subnet

    @property
    def sc_suspended_nodes(self):
        """Gets the sc_suspended_nodes of this SubnetsSubnetPoolsPool.  # noqa: E501

        List of LNNs showing currently suspended nodes in SmartConnect.  # noqa: E501

        :return: The sc_suspended_nodes of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: list[int]
        """
        return self._sc_suspended_nodes

    @sc_suspended_nodes.setter
    def sc_suspended_nodes(self, sc_suspended_nodes):
        """Sets the sc_suspended_nodes of this SubnetsSubnetPoolsPool.

        List of LNNs showing currently suspended nodes in SmartConnect.  # noqa: E501

        :param sc_suspended_nodes: The sc_suspended_nodes of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: list[int]
        """
        if self._configuration.client_side_validation and sc_suspended_nodes is None:
            raise ValueError("Invalid value for `sc_suspended_nodes`, must not be `None`")  # noqa: E501

        self._sc_suspended_nodes = sc_suspended_nodes

    @property
    def sc_ttl(self):
        """Gets the sc_ttl of this SubnetsSubnetPoolsPool.  # noqa: E501

        Time to live value for SmartConnect DNS query responses in seconds.  # noqa: E501

        :return: The sc_ttl of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: int
        """
        return self._sc_ttl

    @sc_ttl.setter
    def sc_ttl(self, sc_ttl):
        """Sets the sc_ttl of this SubnetsSubnetPoolsPool.

        Time to live value for SmartConnect DNS query responses in seconds.  # noqa: E501

        :param sc_ttl: The sc_ttl of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: int
        """
        if self._configuration.client_side_validation and sc_ttl is None:
            raise ValueError("Invalid value for `sc_ttl`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_ttl is not None and sc_ttl > 2147483647):  # noqa: E501
            raise ValueError("Invalid value for `sc_ttl`, must be a value less than or equal to `2147483647`")  # noqa: E501
        if (self._configuration.client_side_validation and
                sc_ttl is not None and sc_ttl < 0):  # noqa: E501
            raise ValueError("Invalid value for `sc_ttl`, must be a value greater than or equal to `0`")  # noqa: E501

        self._sc_ttl = sc_ttl

    @property
    def static_routes(self):
        """Gets the static_routes of this SubnetsSubnetPoolsPool.  # noqa: E501

        List of configured static routes in this network pool  # noqa: E501

        :return: The static_routes of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: list[SubnetsSubnetPoolStaticRoute]
        """
        return self._static_routes

    @static_routes.setter
    def static_routes(self, static_routes):
        """Sets the static_routes of this SubnetsSubnetPoolsPool.

        List of configured static routes in this network pool  # noqa: E501

        :param static_routes: The static_routes of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: list[SubnetsSubnetPoolStaticRoute]
        """
        if self._configuration.client_side_validation and static_routes is None:
            raise ValueError("Invalid value for `static_routes`, must not be `None`")  # noqa: E501

        self._static_routes = static_routes

    @property
    def subnet(self):
        """Gets the subnet of this SubnetsSubnetPoolsPool.  # noqa: E501

        The name of the subnet.  # noqa: E501

        :return: The subnet of this SubnetsSubnetPoolsPool.  # noqa: E501
        :rtype: str
        """
        return self._subnet

    @subnet.setter
    def subnet(self, subnet):
        """Sets the subnet of this SubnetsSubnetPoolsPool.

        The name of the subnet.  # noqa: E501

        :param subnet: The subnet of this SubnetsSubnetPoolsPool.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and subnet is None:
            raise ValueError("Invalid value for `subnet`, must not be `None`")  # noqa: E501
        if (self._configuration.client_side_validation and
                subnet is not None and len(subnet) > 32):
            raise ValueError("Invalid value for `subnet`, length must be less than or equal to `32`")  # noqa: E501
        if (self._configuration.client_side_validation and
                subnet is not None and len(subnet) < 1):
            raise ValueError("Invalid value for `subnet`, length must be greater than or equal to `1`")  # noqa: E501

        self._subnet = subnet

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(SubnetsSubnetPoolsPool, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SubnetsSubnetPoolsPool):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, SubnetsSubnetPoolsPool):
            return True

        return self.to_dict() != other.to_dict()
